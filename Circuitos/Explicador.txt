Usando o STM 32 Cube. Também preciso que o usb recebe dados de calibração se ele não retornar nada ele pega já valores mocados. E deixar os valores mocados para o filtro passa baixa digital.

O meu sistema ta dividido em adc_sensor.h, filter.h, rtc_utils.h, sd_logger.h e usb_common.h a minha main tem isso dividido, preciso melhorar para os novos arquivos:
#define NUM_ADC_CHANNELS 8

#define ADC_BUFFER_SIZE (NUM_ADC_CHANNELS * 64)

#define ADC_TENSAO1       0
#define ADC_TENSAO2       1
#define ADC_CORRENTE1     2
#define ADC_CORRENTE2     3
#define ADC_TEMPERATURA1  4
#define ADC_TEMPERATURA2  5
#define ADC_MASSA1        6
#define ADC_MASSA2        7

#define ADC_MAX_VALUE 4095.0f

#define ADC_VREF 3.3f

#define CALIBRATION_FACTOR_TENSAO1      66.66f
#define CALIBRATION_FACTOR_TENSA2       66.66f

// Fatores de calibração para corrente (A/count_ADC)
#define CALIBRATION_FACTOR_CORRENTE1    0.1f
#define CALIBRATION_FACTOR_CORRENTE2    0.1f

// Fatores de calibração para temperatura (C/count_ADC)
#define CALIBRATION_FACTOR_TEMPERATURA1 100.0f
#define CALIBRATION_FACTOR_TEMPERATURA2 100.0f

// Placeholder para o ADS1232
#define CALIBRATION_FACTOR_MASSA1       0.001f
#define CALIBRATION_FACTOR_MASSA2       0.001f



/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

I2C_HandleTypeDef hi2c1;

RTC_HandleTypeDef hrtc;

SPI_HandleTypeDef hspi2;

PCD_HandleTypeDef hpcd_USB_FS;

DMA_HandleTypeDef hdma_memtomem_dma1_channel2;
/* USER CODE BEGIN PV */
uint16_t adcBuffer[ADC_BUFFER_SIZE];
float tensao1Eng, tensao2Eng;
float corrente1Eng, corrente2Eng;
float temperatura1Eng, temperatura2Eng;
float massa1Eng, massa2Eng;
volatile uint8_t adcDmaTransferComplete = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
static void MX_SPI2_Init(void);
static void MX_RTC_Init(void);
static void MX_USB_PCD_Init(void);
/* USER CODE BEGIN PFP */
void halADCConvCallback(ADC_HandleTypeDef* hadc);
void SDWriteData(char* data);
float ReadADS1232Massa1(void);
float ReadADS1232Massa2(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void halADCConvCallback(ADC_HandleTypeDef* hadc) {
	if(hadc->Instance == ADC1) {
		adcDmaTransferComplete = 1;
	}
}

FATFS fs;
FIL fil;
FRESULT fr;
char log_file[] = "log.txt";

void SDWriteData(char* data)
{
	fr = f_mount(&fs, "", 1);
	if(fr == FR_OK) {
		fr = f_open(&fil, log_file_name, FA_OPEN_ALWAYS | FA_WRITE);
		if(fr == FR_OK) {
			f_lseek(&fil, f_size(&fil));
			f_puts(data, &fil);
			f_close(&fil);
		}
		f_mount(NULL, "", 1);
	}
}

float ReadADS1232Massa(void) {

}

  